#include "cipher_decision_tree.hpp"

#include <sstream>
#include <iostream>
#include <iomanip>

#define TYPE_NONE 0
#define TYPE_SIZE 1
#define TYPE_SEC 2
#define TYPE_CIPHER 3

namespace cryptoengine
{

    const int TREE_SIZE =
    %%tree_size%%;

    static struct
    {
        int left;
        int right;
        int type;
        int size;
        int sec;
        std::string lib;
        std::string alg;
        int key_len;
        std::string mode;
    } decision_tree[] = {
            %%tree_data%%
    };

    static void printRecursive(int leaf_idx, int level)
    {
        if (leaf_idx < 0 || leaf_idx >= TREE_SIZE)
            return;

        std::stringstream ss;
        ss << std::string(level, '\t');

        auto node = decision_tree[leaf_idx];
        if (node.type == TYPE_SIZE)
        {
            ss << "SIZE: LESS OR EQ. THAN " << node.size << " OR GREATER THAN " << node.size << "\n";
        } else if (node.type == TYPE_SEC)
        {
            ss << "SEC: LESS OR EQ. THAN " << node.sec << " OR GREATER THAN " << node.sec << "\n";
        } else if (node.type == TYPE_CIPHER)
        {
            ss << node.lib << " " << node.alg << "-" << node.key_len << "-" << node.mode << "\n";
        } else
        {
            return;
        }

        std::cout << ss.str();

        printRecursive(node.left, level + 1);
        printRecursive(node.right, level + 1);
    }

    void printTree()
    {
        printRecursive(0, 0);
    }

    int findCipher(int file_size, int sec_level, struct CipherInfo &cipher)
    {
        int leaf_idx = 0;
        while (leaf_idx >= 0 && leaf_idx < TREE_SIZE)
        {
            if (decision_tree[leaf_idx].type == TYPE_NONE)
                return 0;

            if (decision_tree[leaf_idx].type == TYPE_SIZE)
            {
                if (decision_tree[leaf_idx].size >= file_size)
                    leaf_idx = decision_tree[leaf_idx].left;
                else
                    leaf_idx = decision_tree[leaf_idx].right;
            } else if (decision_tree[leaf_idx].type == TYPE_SEC)
            {
                if (decision_tree[leaf_idx].sec >= sec_level)
                    leaf_idx = decision_tree[leaf_idx].left;
                else
                    leaf_idx = decision_tree[leaf_idx].right;
            } else if (decision_tree[leaf_idx].type == TYPE_CIPHER)
            {
                cipher.lib = decision_tree[leaf_idx].lib;
                cipher.alg = decision_tree[leaf_idx].alg;
                cipher.key_bits = decision_tree[leaf_idx].key_len;
                cipher.mode = decision_tree[leaf_idx].mode;
                return 1;
            } else
            {
                return 0;
            }
        }

        return 0;
    }

}